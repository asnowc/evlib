## API Report File for "@eavid/lib-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { ChildProcess } from 'node:child_process';
import type * as dgram from 'node:dgram';
import { Duplex } from 'node:stream';
import { EventTrigger } from 'evlib';
import * as net_2 from 'node:net';
import * as node_ps from 'node:child_process';
import * as NodeStream from 'node:stream';
import { OnceEventTrigger } from 'evlib';
import type { Readable } from 'stream';
import { Readable as Readable_2 } from 'node:stream';
import { ReadableStream } from 'node:stream/web';
import { Writable } from 'node:stream';
import { WritableStream } from 'node:stream/web';

// @beta
function bridgingDuplex<A extends Duplex, B extends Duplex>(a: A, b: B, options?: BridgingOptions): Promise<{
    a: A;
    b: B;
}>;

// @public (undocumented)
class BridgingError extends Error {
    constructor(side: Duplex, cause: Error);
    // (undocumented)
    side: Duplex;
}

// @public (undocumented)
interface BridgingOptions {
    preventDispose?: boolean;
}

// @public (undocumented)
interface ByteReader {
    (len: number): Promise<Uint8Array>;
    <T extends Uint8Array = Uint8Array>(view: T): Promise<T>;
}

// @public (undocumented)
type ClosedState = Readonly<{
    code: null | number;
    signal: NodeJS.Signals | null;
}>;

// @alpha
function connect(config: TcpConnectConfig, options?: ConnectOptions): Promise<Connection>;

// @alpha (undocumented)
class Connection extends SocketStream {
    constructor(socket: net_2.Socket);
    enableNagle(enable: boolean): void;
    // (undocumented)
    readonly localAddress: string;
    // (undocumented)
    readonly localFamily: TcpFamily;
    // (undocumented)
    readonly localPort: number;
    // (undocumented)
    readonly remoteAddress: string;
    // (undocumented)
    readonly remoteFamily: TcpFamily;
    // (undocumented)
    readonly remotePort: number;
    resetAndDestroy(): void;
    // (undocumented)
    setKeepAlive(enable?: boolean, delay?: number): void;
    // (undocumented)
    get timeout(): number;
    set timeout(time: number);
    readonly timeoutEvent: EventTrigger<void>;
}

// @public
interface ConnectOptions {
    signal?: AbortSignal;
}

// @alpha (undocumented)
function connectPipe(config: PipeConfig, options?: ConnectOptions): Promise<SocketStream>;

// Warning: (ae-incompatible-release-tags) The symbol "connectSocket" is marked as @public, but its signature references "PipeConfig" which is marked as @alpha
// Warning: (ae-incompatible-release-tags) The symbol "connectSocket" is marked as @public, but its signature references "PipeConfig" which is marked as @alpha
//
// @public
function connectSocket(config: TcpConnectConfig | PipeConfig, options?: ConnectOptions): Promise<net_2.Socket>;

// @public (undocumented)
type CreateIpcServerOpts = Omit<IpcServerOpts, "path">;

// @public (undocumented)
type CreateTcpServerOpts = Omit<TcpServerOpts, "port">;

// @public
function exec(command: string, options?: SpawnOptions & {
    shell?: string;
}): Promise<SubProcess>;

// @public (undocumented)
function execSync(command: string, options?: SpawnSyncOptions & {
    shell?: string;
}): SpawnSyncResult;

// Warning: (ae-incompatible-release-tags) The symbol "fork" is marked as @public, but its signature references "NodeSubProcess" which is marked as @beta
// Warning: (ae-incompatible-release-tags) The symbol "fork" is marked as @public, but its signature references "NodeSubProcess" which is marked as @beta
//
// @public
function fork(file: string, options?: SpawnOptions): Promise<NodeSubProcess>;

// Warning: (ae-forgotten-export) The symbol "ServerOpts" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface IpcServerOpts extends ServerOpts {
    // (undocumented)
    path?: string;
    readableAll?: boolean;
    // (undocumented)
    type: "IPC";
    writableAll?: boolean;
}

declare namespace module_2 {
    export {
        paseModMeta,
        ModuleMeta
    }
}
export { module_2 as module }

// @public (undocumented)
interface ModuleMeta {
    dirname: string;
    filename: string;
    pathname: string;
    // (undocumented)
    protocol: string;
}

declare namespace net {
    export {
        connect,
        connectSocket,
        connectPipe,
        SocketStream,
        TcpFamily,
        Connection,
        TcpConnectConfig,
        ConnectOptions,
        PipeConfig,
        TcpServerOpts,
        IpcServerOpts,
        ServerListenOpts,
        CreateTcpServerOpts,
        CreateIpcServerOpts,
        Server
    }
}
export { net }

// @beta (undocumented)
class NodeSubProcess extends SubProcess {
    constructor(nodeCps: ChildProcess);
    // (undocumented)
    get connected(): boolean;
    disconnect(): void;
    // (undocumented)
    protected readonly disconnectEvent: OnceEventTrigger<void>;
    // (undocumented)
    readonly messageEvent: EventTrigger<unknown>;
    // Warning: (ae-forgotten-export) The symbol "Handle" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    send(msg: any, handle?: Handle | number): Promise<unknown>;
    // (undocumented)
    watchDisconnect(signal?: AbortSignal): Promise<void>;
}

// @public
function paseModMeta(meta: {
    url: string;
}): ModuleMeta;

// @alpha (undocumented)
interface PipeConfig {
    fd?: number;
    path: string;
    readable?: boolean;
    writable?: boolean;
}

// @beta (undocumented)
interface PipeOptions {
    preventReadableDispose?: boolean;
    preventWritableDispose?: boolean;
    preventWritableEnd?: boolean;
}

// @public
class PipeSourceError extends Error {
    constructor(cause: Error);
    // (undocumented)
    cause: Error;
}

// @public
class PipeTargetError extends Error {
    constructor(cause: Error);
    // (undocumented)
    cause: Error;
}

// Warning: (ae-forgotten-export) The symbol "WithPromise" needs to be exported by the entry point index.d.ts
//
// @beta (undocumented)
function pipeTo<T extends Readable_2, R extends Writable>(source: T, target: R, options?: PipeOptions): WithPromise<{
    abort(reason?: Error): void;
}, void>;

declare namespace process_2 {
    export {
        ClosedState,
        SubProcess,
        SpawnOptions,
        SpawnSyncResult,
        SpawnSyncOptions,
        spawn,
        spawnSync,
        fork,
        NodeSubProcess,
        exec,
        execSync
    }
}
export { process_2 as process }

// @alpha
function readableRead(stream: Readable, len: number, abortSignal?: AbortSignal): Promise<Buffer>;

// @public
function readableStreamToByteReader<T extends Uint8Array>(stream: ReadableStream<T>): {
    read: ByteReader;
    cancel(reason?: Error): Uint8Array | null;
};

// @public
function readableToAsyncIterator<T extends Uint8Array>(readable: Readable_2): AsyncGenerator<T, void, void>;

// @public
function readableToByteReader(stream: Readable_2): {
    read: ByteReader;
    cancel(reason?: Error): Buffer | null;
};

// @public
function readableToReadableStream<T = Uint8Array>(readable: Readable_2): ReadableStream<T>;

// @public
function readAllFromStream<T>(stream: ReadableStream<T>): Promise<T[]>;

// @public (undocumented)
class Server {
    [Symbol.asyncDispose](): Promise<void>;
    constructor(onConn: (conn: net_2.Socket) => void, options?: TcpServerOpts | undefined);
    constructor(onConn: (conn: net_2.Socket) => void, options?: IpcServerOpts | undefined);
    constructor(onConn: (conn: net_2.Socket) => void, options?: TcpServerOpts | IpcServerOpts | undefined);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    readonly closeEvent: OnceEventTrigger<void>;
    disposeQueue: boolean;
    // (undocumented)
    readonly errorEvent: EventTrigger<Error>;
    // @alpha (undocumented)
    get fd(): number | Object;
    get keepCount(): number;
    // @alpha (undocumented)
    static listen(onConn: (conn: Connection) => void, options?: TcpServerOpts): Promise<Server>;
    // Warning: (ae-incompatible-release-tags) The symbol "listen" is marked as @public, but its signature references "SocketStream" which is marked as @alpha
    // Warning: (ae-incompatible-release-tags) The symbol "listen" is marked as @public, but its signature references "SocketStream" which is marked as @alpha
    //
    // (undocumented)
    static listen(onConn: (conn: SocketStream) => void, options?: IpcServerOpts): Promise<Server>;
    // (undocumented)
    listen(options?: ServerListenOpts): Promise<void>;
    // (undocumented)
    get listening(): boolean;
    // (undocumented)
    ref(): void;
    // (undocumented)
    readonly type: "IPC" | "TCP";
    // (undocumented)
    unref(): void;
    // (undocumented)
    watchClose(signal?: AbortSignal): Promise<void>;
}

// @public (undocumented)
interface ServerListenOpts {
    // (undocumented)
    host?: string;
    // (undocumented)
    path?: string;
    // (undocumented)
    port?: number;
}

// Warning: (ae-forgotten-export) The symbol "DuplexStream" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
class SocketStream extends DuplexStream<Buffer> {
    constructor(socket: net_2.Socket);
    get bytesRead(): number;
    get bytesWritten(): number;
    // (undocumented)
    ref(): void;
    // (undocumented)
    protected socket: net_2.Socket;
    // (undocumented)
    unref(): void;
}

// @public (undocumented)
function spawn(exePath: string, options?: SpawnOptions): Promise<SubProcess>;

// Warning: (ae-forgotten-export) The symbol "SpawnCommonOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
interface SpawnOptions extends SpawnCommonOptions {
    detached?: boolean;
}

// @public (undocumented)
function spawnSync(exePath: string, options?: SpawnSyncOptions): SpawnSyncResult;

// @public (undocumented)
interface SpawnSyncOptions extends SpawnCommonOptions {
    // (undocumented)
    maxBuffer?: number;
}

// @public (undocumented)
interface SpawnSyncResult {
    // (undocumented)
    error?: Error | undefined;
    // (undocumented)
    pid: number;
    // (undocumented)
    signal: NodeJS.Signals | null;
    // (undocumented)
    status: number | null;
    // (undocumented)
    stderr: Buffer;
    // (undocumented)
    stdout: Buffer;
}

declare namespace stream {
    export {
        readAllFromStream,
        ByteReader,
        readableRead,
        pipeTo,
        bridgingDuplex,
        PipeOptions,
        BridgingOptions,
        PipeSourceError,
        PipeTargetError,
        BridgingError,
        readableStreamToByteReader,
        readableToByteReader,
        readableToAsyncIterator,
        readableToReadableStream,
        writableToWritableStream
    }
}
export { stream }

// @public (undocumented)
class SubProcess {
    constructor(nodeCps: node_ps.ChildProcess);
    // (undocumented)
    readonly closed: boolean;
    // (undocumented)
    closedState: ClosedState | null;
    // @alpha
    protected readonly closeEvent: OnceEventTrigger<Readonly<{
        code: number | null;
        signal: NodeJS.Signals | null;
    }>>;
    protected readonly exitEvent: OnceEventTrigger<Readonly<{
        code: number | null;
        signal: NodeJS.Signals | null;
    }>>;
    // (undocumented)
    kill(signal?: NodeJS.Signals | number): void;
    // (undocumented)
    get killed(): boolean;
    // (undocumented)
    protected nodeCps: node_ps.ChildProcess;
    // (undocumented)
    readonly pid: number;
    // (undocumented)
    ref(): void;
    // (undocumented)
    readonly spawnargs: readonly string[];
    // (undocumented)
    readonly spawnFile: string;
    // (undocumented)
    readonly stderr: null | ReadableStream<Buffer>;
    // (undocumented)
    readonly stdin: null | WritableStream<Buffer>;
    // (undocumented)
    readonly stdio: readonly [
    WritableStream<Buffer> | null,
    ReadableStream<Buffer> | null,
    ReadableStream<Buffer> | null
    ];
    // (undocumented)
    readonly stdout: null | ReadableStream<Buffer>;
    // (undocumented)
    unref(): void;
    // (undocumented)
    watchClose(signal?: AbortSignal): Promise<Readonly<{
        code: number | null;
        signal: NodeJS.Signals | null;
    }>>;
    // (undocumented)
    watchExit(signal?: AbortSignal): Promise<Readonly<{
        code: number | null;
        signal: NodeJS.Signals | null;
    }>>;
}

// @public
interface TcpConnectConfig {
    family?: 4 | 6 | 0;
    // (undocumented)
    host?: string;
    localAddress?: string;
    localPort?: number;
    // (undocumented)
    port: number;
}

// @public (undocumented)
type TcpFamily = "IPv4" | "IPv6";

// @public (undocumented)
interface TcpServerOpts extends ServerOpts {
    // (undocumented)
    host?: string;
    // (undocumented)
    ipv6Only?: boolean;
    // (undocumented)
    port?: number;
    // (undocumented)
    type?: "TCP";
}

// @public
function writableToWritableStream<T = Uint8Array>(writable: Writable): WritableStream<T>;

// (No @packageDocumentation comment for this package)

```
