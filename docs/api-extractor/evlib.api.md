## API Report File for "evlib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
class AbortedError extends Error {
}

// @public
function afterTime(time?: number): TerminablePromise<void>;

// Warning: (ae-forgotten-export) The symbol "ArrayChecker" needs to be exported by the entry point index.d.ts
//
// @public
const array: ArrayChecker;

declare namespace async {
    export {
        DataCollector,
        ByteParser,
        LengthByteParser,
        StepsByteParser,
        PromiseConcurrencyOption,
        PromiseConcurrency
    }
}

// @public
function autoUnitByte(number: number, raids?: number, unit?: "B" | "KB" | "MB" | "GB" | "TB" | "PB"): string;

// @public (undocumented)
type BasicType = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function" | "null";

// Warning: (ae-forgotten-export) The symbol "BySteps" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
abstract class ByteParser<T> implements BySteps<T> {
    // (undocumented)
    finish(): ParserResult<T>;
    // (undocumented)
    abstract next(chunk: Uint8Array): boolean;
    // Warning: (ae-forgotten-export) The symbol "ParserResult" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected result?: ParserResult<T>;
}

// @public
interface CacheQueue<T> extends Queue<T> {
    maxSize: number;
    size: number;
}

// Warning: (ae-forgotten-export) The symbol "Fn" needs to be exported by the entry point index.d.ts
//
// @public
type CallChian<T extends Fn = Fn> = {
    (...args: Parameters<T>): ReturnType<T>;
    [key: string | number | symbol]: CallChian<T>;
};

// @public
function checkType<T extends ExpectType>(value: any, except: T, options?: TypeCheckOptions): TypeCheckResult<InferExpect<T>>;

// @public
interface ControllablePromise<T> extends Promise<T> {
    // (undocumented)
    reject(reason?: any): void;
    // (undocumented)
    resolve(data: T): void;
}

declare namespace core {
    export {
        ECMA_VERSION,
        runtimeEngine,
        setTimer,
        setInterval_2 as setInterval,
        afterTime,
        wakeUpIn,
        withPromise,
        dePromise,
        WithPromise,
        VoidFn,
        TerminablePromise,
        PromiseHandle,
        ControllablePromise,
        ObjectKey,
        patchObject,
        groupObject,
        removeUndefinedKey,
        pickObjectKey,
        deepClone,
        PatchObjectOpts,
        toErrorStr,
        EventTrigger,
        Listenable,
        OnceListenable,
        OnceEventTrigger,
        NumericalRangeError,
        TimeoutError,
        createTypeErrorDesc,
        TypeError_2 as TypeError,
        ParameterError,
        ParameterTypeError,
        NotImplementedError,
        AbortedError,
        listenSignal
    }
}

// @public
function createList<T>(fn: (index: number) => T, size: number, startIndex?: number): T[];

// Warning: (ae-forgotten-export) The symbol "ProxyTarget" needs to be exported by the entry point index.d.ts
//
// @public
function createObjectChain<T extends Fn = Fn>(createProxy?: () => ProxyTarget<T>): CallChian<T>;

// @public
function createObjectChain(createProxy?: () => object): ObjectChian;

// @public
function createObjectChain<T extends Fn = Fn>(key: string, extend?: object, createProxy?: () => ProxyTarget<T>): CallChian<T>;

// @public
function createObjectChain(key: string, extend?: object, createProxy?: () => object): ObjectChian;

// @public
function createTypeErrorDesc(expect: string, actual: string): string;

// @public (undocumented)
type CustomChecker<T = unknown> = TypeChecker<T> | TypeCheckFn<T>;

declare namespace data_struct {
    export {
        UniqueKeyMap,
        eachLinkedList,
        getLinkedListByIndex,
        SinglyLinkList,
        DoublyLinkList,
        Queue,
        CacheQueue,
        LinkedQueue,
        LinkedCacheQueue,
        LoopUniqueId
    }
}

// @public
class DataCollector<T, R = void> {
    // (undocumented)
    [Symbol.asyncIterator](): this;
    close(data: R): void;
    // (undocumented)
    next(): Promise<IteratorResult<T, R>>;
    return(value: R): Promise<IteratorResult<T, R>>;
    // (undocumented)
    throw(e: any): Promise<IteratorResult<T, R>>;
    yield(data: T): void;
}

// @public
function deepClone<T>(obj: T, cloned?: Map<any, any>): T;

// @public
function dePromise<T, R>(val: T | Promise<T>, fn: (val: T) => R): R | Promise<R>;

// @public (undocumented)
type DoublyLinkList<T extends object = {}> = {
    before?: DoublyLinkList<T>;
    next?: DoublyLinkList<T>;
};

// @public
function eachLinkedList<T extends object>(link?: SinglyLinkList<T>): Generator<SinglyLinkList<T>, void, void>;

// @public
const ECMA_VERSION: number;

// @public
function enumType<T>(expects: T[]): TypeCheckFn<T>;

// @public (undocumented)
const EventTrigger: new <T>() => EventTrigger<T>;

// Warning: (ae-forgotten-export) The symbol "EventTriggerController" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type EventTrigger<T> = Listenable<T> & EventTriggerController<T>;

// @public
type ExpectType<T = unknown> = TypeCheckFn<T> | TypeChecker<T> | BasicType | ExpectTypeObject | ExpectTypeTuple;

// @public
type ExpectTypeObject = {
    [key: string | number]: ExpectType;
    [key: symbol]: any;
};

// @public
type ExpectTypeTuple = ExpectType[];

// @public (undocumented)
type ExponentFormat = {
    int: number;
    decimals: number;
    exponent: number;
};

// @public
function getBasicType(val: any): BasicType;

// @public
function getChainPath(obj: object): string[];

// @public
function getClassType(val: any): string;

// @public
function getLinkedListByIndex<T extends object>(link: SinglyLinkList<T>, index: number): SinglyLinkList<T>;

// @beta
function groupObject<T extends {}>(data: T[], key: keyof T): Obj<T>;

// Warning: (ae-forgotten-export) The symbol "InferBaseMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InferTuple" needs to be exported by the entry point index.d.ts
//
// @public
type InferExpect<T> = T extends string ? InferBaseMap[T] : T extends any[] ? InferTuple<T> : T extends TypeCheckFn<infer E> ? E : T extends TypeChecker<infer E> ? E : T extends object ? {
    [key in keyof T]: InferExpect<T[key]>;
} : unknown;

// @public
function instanceOf<T extends new (...args: any[]) => any>(obj: T): TypeCheckFn<InstanceType<T>>;

// @alpha (undocumented)
class LengthByteParser extends ByteParser<Uint8Array> {
    constructor(total: number);
    // (undocumented)
    next(buf: Uint8Array): boolean;
    // (undocumented)
    readonly total: number;
}

// @public
class LinkedCacheQueue<T extends object> extends LinkedQueue<T> implements CacheQueue<T> {
    constructor(maxSize: number);
    // (undocumented)
    get maxSize(): number;
    set maxSize(maxSize: number);
    // (undocumented)
    push(data: T): void;
    // (undocumented)
    unshift(data: T): void;
}

// @public
class LinkedQueue<T extends object> implements Queue<T> {
    // (undocumented)
    [Symbol.iterator](): Generator<SinglyLinkList<T>, void, void>;
    clear(): void;
    // (undocumented)
    head?: SinglyLinkList<T>;
    // (undocumented)
    last?: SinglyLinkList<T>;
    // (undocumented)
    push(data: T): void;
    shift(): T;
    // (undocumented)
    size: number;
    unshift(data: T): void;
}

// @public
interface Listenable<T> {
    // (undocumented)
    done: boolean;
    off(key: object): boolean;
    on<R extends Listener<T>>(listener: R): R;
    // Warning: (ae-forgotten-export) The symbol "Listener" needs to be exported by the entry point index.d.ts
    once<R extends Listener<T>>(resolve: R): R;
    then(resolve: Listener<T>): void;
}

// @public
function listenSignal(signal: PruneAbortSignal | undefined, listener: (this: PruneAbortSignal) => void): {
    [Symbol.dispose](): void;
    dispose(): void;
};

// @public
class LoopUniqueId {
    constructor(min?: number, max?: number);
    // (undocumented)
    max: number;
    // (undocumented)
    min: number;
    next(): number;
    // (undocumented)
    reset(): void;
}

declare namespace math {
    export {
        retainDecimalsFloor,
        retainDecimalsRound,
        paseExponentNum,
        autoUnitByte,
        ExponentFormat,
        randomInt
    }
}

declare namespace mock {
    export {
        createList,
        randomString
    }
}

// @public (undocumented)
class NotImplementedError extends Error {
    constructor(type?: string);
}

// @public
function numberRange(min: number, max?: number): TypeCheckFn<number>;

// @public
class NumericalRangeError extends RangeError {
    constructor(min?: number, max?: number, valueName?: string);
}

declare namespace object {
    export {
        getChainPath,
        createObjectChain,
        ObjectChian,
        CallChian
    }
}

// @public
type ObjectChian = {
    [key: string | number | symbol]: ObjectChian;
};

// @public (undocumented)
type ObjectKey = string | number | symbol;

// @public
class OnceEventTrigger<T> implements OnceListenable<T> {
    // (undocumented)
    catch(listener: (err: any) => void): void;
    // (undocumented)
    get done(): boolean;
    emit(arg: T): number;
    emitError(err: any): number;
    // (undocumented)
    finally(listener: () => void): void;
    // Warning: (ae-forgotten-export) The symbol "PruneAbortSignal" needs to be exported by the entry point index.d.ts
    getPromise(signal?: PruneAbortSignal): Promise<T>;
    // (undocumented)
    off(key: object): boolean;
    once<R extends Listener<T>>(resolve: R, reject?: (arg: any) => void): R;
    // (undocumented)
    then(resolve: Listener<T>, reject?: (arg: any) => void): void;
}

// @public
interface OnceListenable<T> {
    catch<R extends (reason: any) => void>(listener: R): void;
    done: boolean;
    finally(listener: () => void): void;
    off(key: object): boolean;
    once<R extends Listener<T>>(resolve: R): R;
    then(resolve: Listener<T>, reject?: (data?: any) => void): void;
}

// Warning: (ae-forgotten-export) The symbol "OptionalChecker" needs to be exported by the entry point index.d.ts
//
// @public
const optional: OptionalChecker;

// @public (undocumented)
class ParameterError extends Error {
    constructor(index: number, cause: string, name?: string);
}

// @public (undocumented)
class ParameterTypeError extends ParameterError {
    constructor(index: number, expect: string, actual: string, name?: string);
}

// @public
function paseExponentNum(num: number, carry: number, maxExponent?: number): ExponentFormat;

// @public
function paseExponentNum(num: number, carry: number[]): ExponentFormat;

// Warning: (ae-forgotten-export) The symbol "Obj" needs to be exported by the entry point index.d.ts
//
// @public
function patchObject<T = unknown>(from: Obj, to: Obj, opts?: PatchObjectOpts): T;

// @public (undocumented)
type PatchObjectOpts = {
    skipUndefined?: boolean;
    arrayStrategy?: "unshift" | "push" | "replace";
};

// @public
function pickObjectKey<P extends {}>(obj: Object, keys: (keyof P)[] | Set<keyof P>, target?: Object): P;

// @public (undocumented)
function pickObjectKey(obj: Object, keys: string[] | Set<any>, target?: Object): Record<string, unknown>;

// @public
class PromiseConcurrency {
    constructor(config: PromiseConcurrencyOption);
    concurrency: number;
    failedTotal: number;
    maxFailed: number;
    onClear(): Promise<void>;
    processingCount: number;
    push(...data: Promise<void | any>[]): Promise<void>;
}

// @public (undocumented)
interface PromiseConcurrencyOption {
    concurrency: number;
    maxFailed?: number;
}

// @public (undocumented)
interface PromiseHandle<T> {
    // (undocumented)
    reject(reason?: any): void;
    // (undocumented)
    resolve(data: T): void;
}

// @public (undocumented)
interface Queue<T> {
    head?: T;
    push(data: T): void;
    shift(): T;
}

// @public
function randomInt(max: number): number;

// @public
function randomInt(min: number, max: number): number;

// @public
function randomString(len: number, minUnicode?: number, maxUnicode?: number): string;

// Warning: (ae-forgotten-export) The symbol "RecordChecker" needs to be exported by the entry point index.d.ts
//
// @public
const record: RecordChecker;

// @public
function removeUndefinedKey<T extends Obj>(obj: T, deep?: boolean): T;

// @public (undocumented)
function retainDecimalsFloor(num: number, raids?: number): number;

// @public (undocumented)
function retainDecimalsRound(num: number, raids?: number): number;

// @public
const runtimeEngine: "node" | "browser" | "deno" | "bun" | "unknown";

// @public
function setInterval_2(fn: VoidFn, intervalTime?: number): () => void;

// @public
function setTimer(fn: VoidFn, timeout?: number): () => void;

// @public (undocumented)
type SinglyLinkList<T extends object = {}> = T & {
    next?: SinglyLinkList<T>;
};

// @alpha (undocumented)
class StepsByteParser<T> extends ByteParser<T> {
    constructor(opts: {
        first: BySteps<any>;
        final?: (data: any) => T;
    }, ...steps: ((data: any) => BySteps<any>)[]);
    // (undocumented)
    next(chunk: Uint8Array): boolean;
    // (undocumented)
    step: number;
}

// @public
interface TerminablePromise<T> extends Promise<T> {
    // (undocumented)
    abort(reason?: Error): void;
}

// @public
class TimeoutError extends Error {
    constructor(time?: number);
}

// @public
function toErrorStr(err?: any, showStack?: boolean): string;

// @public (undocumented)
const TYPE_CHECK_FN: unique symbol;

// @public
interface TypeChecker<T = unknown> {
    // (undocumented)
    [TYPE_CHECK_FN]: TypeCheckFn<T>;
    baseType?: BasicType;
    // (undocumented)
    optional?: boolean;
}

// @public
interface TypeCheckFn<T = any> {
    // (undocumented)
    (val: any, option: Readonly<TypeCheckOptions>): TypeCheckFnCheckResult<T>;
    baseType?: BasicType;
}

// Warning: (ae-forgotten-export) The symbol "TypeCheckError" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TypeCheckReplace" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type TypeCheckFnCheckResult<T = unknown> = TypeCheckError | TypeCheckReplace<T> | void;

// @public (undocumented)
interface TypeCheckOptions {
    checkAll?: boolean;
    policy?: "pass" | "delete" | "error";
}

// @public (undocumented)
type TypeCheckResult<T = unknown> = {
    error?: TypeErrorDesc_2;
    value: T;
};

// @public (undocumented)
class TypeError_2 extends Error {
    constructor(cause: TypeErrorDesc, msg?: string);
    // Warning: (ae-forgotten-export) The symbol "TypeErrorDesc" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cause: TypeErrorDesc;
}

// @public
type TypeErrorDesc_2 = string | {
    [key: string]: TypeErrorDesc_2;
};

// @public
function union<T extends ExpectType[]>(types: T): TypeCheckFn<InferExpect<T[number]>> | TypeChecker<InferExpect<T[number]>>;

// @public
class UniqueKeyMap<T = any> extends Map<number, T> {
    constructor(maxSize: number);
    allocKeySet(data: T, safe?: undefined | false): number;
    allocKeySet(data: T, safe?: boolean): number | null;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(key: number): boolean;
    // (undocumented)
    get freeRange(): number;
    // (undocumented)
    get freeSize(): number;
    // (undocumented)
    get lastPointer(): number;
    // (undocumented)
    readonly maxSize: number;
    set(key: number, data: T): this;
    // (undocumented)
    get startPointer(): number;
    take(key: number): T | undefined;
    update(key: number, data: T): boolean;
}

declare namespace validator {
    export {
        checkType,
        verifyType,
        TypeCheckResult,
        getBasicType,
        getClassType,
        numberRange,
        instanceOf,
        union,
        enumType,
        optional,
        array,
        record,
        TYPE_CHECK_FN,
        TypeChecker,
        TypeErrorDesc_2 as TypeErrorDesc,
        TypeCheckFn,
        CustomChecker,
        BasicType,
        ExpectTypeTuple,
        ExpectTypeObject,
        ExpectType,
        TypeCheckOptions,
        TypeCheckFnCheckResult,
        InferExpect
    }
}

// @public
function verifyType<T extends ExpectType>(input: any, expect: T): InferExpect<T>;

// @public
interface VoidFn {
    // (undocumented)
    (): void;
}

// @public
function wakeUpIn(min: number): () => Promise<void>;

// @public (undocumented)
interface WithPromise<T, R = any> {
    // (undocumented)
    promise: Promise<T>;
    // (undocumented)
    reject(data: R): void;
    // (undocumented)
    resolve(data: T): void;
}

// @public
function withPromise<T, R = any, E extends object = {}>(handle?: E): WithPromise<T, R> & E;

// (No @packageDocumentation comment for this package)

```
