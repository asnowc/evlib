## API Report File for "evlib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
class AbortedError extends Error {
}

// @public
function afterTime(time?: number): TerminablePromise<void>;

declare namespace async {
    export {
        InquiryRequest,
        DataCollector,
        ByteParser,
        LengthByteParser,
        StepsByteParser
    }
}
export { async }

// @public (undocumented)
const autoUnit: {
    byte(number: number, raids?: number, unit?: "B" | "KB" | "MB" | "GB" | "TB" | "PB"): string;
};

// @public (undocumented)
type BasicType = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function" | "null";

// Warning: (ae-forgotten-export) The symbol "BySteps" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
abstract class ByteParser<T> implements BySteps<T> {
    // (undocumented)
    finish(): ParserResult<T>;
    // (undocumented)
    abstract next(chunk: Uint8Array): boolean;
    // Warning: (ae-forgotten-export) The symbol "ParserResult" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected result?: ParserResult<T>;
}

// @public
interface CacheQueue<T> extends Queue<T> {
    maxSize: number;
    size: number;
}

// Warning: (ae-forgotten-export) The symbol "Fn_2" needs to be exported by the entry point index.d.ts
//
// @public
type CallChian<T extends Fn_2 = Fn_2> = {
    (...args: Parameters<T>): ReturnType<T>;
    [key: string | number | symbol]: CallChian<T>;
};

// Warning: (ae-forgotten-export) The symbol "TypeCheckResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function checkType<T extends ExceptType>(value: any, except: T, options?: TypeCheckOptions): TypeCheckResult<InferExcept<T>>;

// @public
interface ControllablePromise<T> extends Promise<T> {
    // (undocumented)
    reject(reason?: any): void;
    // (undocumented)
    resolve(data: T): void;
}

declare namespace core {
    export {
        ECMA_VERSION,
        runtimeEngine,
        checkType,
        getBasicType,
        getClassType,
        typeChecker,
        TYPE_CHECK_FN,
        TypeChecker,
        TypeErrorDesc,
        TypeCheckFn,
        BasicType,
        ExceptTypeTuple,
        ExceptTypeMap,
        ExceptTypeObject,
        ExceptType,
        TypeCheckOptions,
        TypeCheckFnCheckResult,
        InferExcept,
        setTimer,
        setInterval_2 as setInterval,
        afterTime,
        withPromise,
        dePromise,
        WithPromise,
        VoidFn,
        TerminablePromise,
        PromiseHandle,
        ControllablePromise,
        ObjectKey,
        Enum,
        patchObject,
        groupObject,
        removeUndefinedKey,
        pickObjectKey,
        deepClone,
        PatchObjectOpts,
        toErrorStr,
        EventTrigger,
        Listenable,
        OnceListenable,
        OnceEventTrigger
    }
}
export { core }

// @public
function createList<T>(fn: (index: number) => T, size: number, startIndex?: number): T[];

// Warning: (ae-forgotten-export) The symbol "ProxyTarget" needs to be exported by the entry point index.d.ts
//
// @public
function createObjectChain<T extends Fn_2 = Fn_2>(createProxy?: () => ProxyTarget<T>): CallChian<T>;

// @public
function createObjectChain(createProxy?: () => object): ObjectChian;

// @public
function createObjectChain<T extends Fn_2 = Fn_2>(key: string, extend?: object, createProxy?: () => ProxyTarget<T>): CallChian<T>;

// @public
function createObjectChain(key: string, extend?: object, createProxy?: () => object): ObjectChian;

// @public
function createTypeErrorDesc(except: string, actual: string): string;

declare namespace data_struct {
    export {
        UniqueKeyMap,
        eachLinkedList,
        getLinkedListByIndex,
        SinglyLinkList,
        DoublyLinkList,
        Queue,
        CacheQueue,
        LinkedQueue,
        LinkedCacheQueue,
        LoopUniqueId
    }
}
export { data_struct }

// @public
class DataCollector<T, R = void> implements AsyncGenerator<T, R, void> {
    // (undocumented)
    [Symbol.asyncIterator](): this;
    close(data: R): void;
    // (undocumented)
    next(): Promise<IteratorResult<T, R>>;
    return(value: R): Promise<IteratorResult<T, R>>;
    // (undocumented)
    throw(e: any): Promise<IteratorResult<T, R>>;
    yield(data: T): void;
}

// @public
function deepClone<T>(obj: T, cloned?: Map<any, any>): T;

// @public
function dePromise<T, R>(val: T | Promise<T>, fn: (val: T) => R): R | Promise<R>;

// @public (undocumented)
type DoublyLinkList<T extends object = {}> = {
    before?: DoublyLinkList<T>;
    next?: DoublyLinkList<T>;
};

// @public
function eachLinkedList<T extends object>(link?: SinglyLinkList<T>): Generator<SinglyLinkList<T>, void, unknown>;

// @public
const ECMA_VERSION: number;

// @alpha (undocumented)
const Enum: {
    getKeys(enumObj: Record<string, string | number>): string[];
};

declare namespace errors {
    export {
        NumericalRangeError,
        TimeoutError,
        createTypeErrorDesc,
        TypeError_2 as TypeError,
        ParameterError,
        ParameterTypeError,
        NotImplementedError,
        AbortedError
    }
}
export { errors }

// @public (undocumented)
const EventTrigger: new <T>() => EventTrigger<T>;

// Warning: (ae-forgotten-export) The symbol "EventTriggerController" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type EventTrigger<T> = Listenable<T> & EventTriggerController<T>;

// @public
type ExceptType = TypeCheckFn | TypeChecker | BasicType | ExceptTypeObject | ExceptTypeTuple;

// @public @deprecated
type ExceptTypeMap = ExceptTypeObject;

// @public
type ExceptTypeObject = {
    [key: string | number]: ExceptType;
    [key: symbol]: any;
};

// @public
type ExceptTypeTuple = ExceptType[];

// @public (undocumented)
type ExponentFormat = {
    int: number;
    decimals: number;
    exponent: number;
};

// @public
function getBasicType(val: any): BasicType;

// @public
function getChainPath(obj: object): string[];

// @public
function getClassType(val: any): string;

// @public
function getLinkedListByIndex<T extends object>(link: SinglyLinkList<T>, index: number): SinglyLinkList<T>;

// @beta
function groupObject<T extends {}>(data: T[], key: keyof T): Obj<T>;

// Warning: (ae-forgotten-export) The symbol "InferBaseMap" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "InferTuple" needs to be exported by the entry point index.d.ts
//
// @public
type InferExcept<T> = T extends string ? InferBaseMap[T] : T extends any[] ? InferTuple<T> : T extends TypeCheckFn<infer E> ? E : T extends TypeChecker<infer E> ? E : T extends object ? {
    [key in keyof T]: InferExcept<T[key]>;
} : unknown;

// @alpha (undocumented)
class InquiryRequest<AcceptReturn = unknown, RejectReturn = unknown, AcceptArgs extends any[] = [], RejectArgs extends any[] = []> {
    constructor(acceptCb: (...args: AcceptArgs) => AcceptReturn, rejectCb: (...args: RejectArgs) => RejectReturn);
    // (undocumented)
    accept(...args: AcceptArgs): AcceptReturn;
    // (undocumented)
    reject(...args: RejectArgs): RejectReturn;
    // (undocumented)
    get status(): boolean | undefined;
}

// @alpha (undocumented)
class LengthByteParser extends ByteParser<Uint8Array> {
    constructor(total: number);
    // (undocumented)
    next(buf: Uint8Array): boolean;
    // (undocumented)
    readonly total: number;
}

// @public
class LinkedCacheQueue<T extends object> extends LinkedQueue<T> implements CacheQueue<T> {
    constructor(maxSize: number);
    // (undocumented)
    get maxSize(): number;
    set maxSize(maxSize: number);
    // (undocumented)
    push(data: T): void;
    // (undocumented)
    unshift(data: T): void;
}

// @public
class LinkedQueue<T extends object> implements Queue<T> {
    // (undocumented)
    [Symbol.iterator](): Generator<SinglyLinkList<T>, void, unknown>;
    clear(): void;
    // (undocumented)
    head?: SinglyLinkList<T>;
    // (undocumented)
    last?: SinglyLinkList<T>;
    // (undocumented)
    push(data: T): void;
    shift(): T;
    // (undocumented)
    size: number;
    unshift(data: T): void;
}

// @public
interface Listenable<T> {
    // (undocumented)
    done: boolean;
    off(key: object): boolean;
    on<R extends Listener<T>>(listener: R): R;
    // Warning: (ae-forgotten-export) The symbol "Listener" needs to be exported by the entry point index.d.ts
    once<R extends Listener<T>>(resolve: R): R;
    then(resolve: Listener<T>): void;
}

// @public
class LoopUniqueId {
    constructor(min?: number, max?: number);
    // (undocumented)
    max: number;
    // (undocumented)
    min: number;
    next(): number;
    // (undocumented)
    reset(): void;
}

declare namespace math {
    export {
        retainDecimalsFloor,
        retainDecimalsRound,
        paseExponentNum,
        ExponentFormat,
        autoUnit,
        randomInt
    }
}
export { math }

declare namespace mock {
    export {
        createList,
        randomString
    }
}
export { mock }

// @public (undocumented)
class NotImplementedError extends Error {
    constructor(type?: string);
}

// @public
class NumericalRangeError extends RangeError {
    constructor(min?: number, max?: number, valueName?: string);
}

declare namespace object {
    export {
        getChainPath,
        createObjectChain,
        ObjectChian,
        CallChian
    }
}
export { object }

// @public
type ObjectChian = {
    [key: string | number | symbol]: ObjectChian;
};

// @public (undocumented)
type ObjectKey = string | number | symbol;

// @public
class OnceEventTrigger<T> implements OnceListenable<T> {
    // (undocumented)
    catch(listener: (err: any) => void): void;
    // (undocumented)
    get done(): boolean;
    emit(arg: T): number;
    emitError(err: any): number;
    // (undocumented)
    finally(listener: () => void): void;
    // Warning: (ae-forgotten-export) The symbol "BaseAbortSignal" needs to be exported by the entry point index.d.ts
    getPromise(signal?: BaseAbortSignal): Promise<T>;
    // (undocumented)
    off(key: object): boolean;
    once<R extends Listener<T>>(resolve: R, reject?: (arg: any) => void): R;
    // (undocumented)
    then(resolve: Listener<T>, reject?: (arg: any) => void): void;
}

// @public
interface OnceListenable<T> {
    catch<R extends (reason: any) => void>(listener: R): void;
    done: boolean;
    finally(listener: () => void): void;
    off(key: object): boolean;
    once<R extends Listener<T>>(resolve: R): R;
    then(resolve: Listener<T>, reject?: (data?: any) => void): void;
}

// @public (undocumented)
class ParameterError extends Error {
    constructor(index: number, cause: string, name?: string);
}

// @public (undocumented)
class ParameterTypeError extends ParameterError {
    constructor(index: number, except: string, actual: string, name?: string);
}

// @public
function paseExponentNum(num: number, carry: number, maxExponent?: number): ExponentFormat;

// @public
function paseExponentNum(num: number, carry: number[]): ExponentFormat;

// Warning: (ae-forgotten-export) The symbol "Obj" needs to be exported by the entry point index.d.ts
//
// @public
function patchObject<T = unknown>(from: Obj, to: Obj, opts?: PatchObjectOpts): T;

// @public (undocumented)
type PatchObjectOpts = {
    skipUndefined?: boolean;
    arrayStrategy?: "unshift" | "push" | "replace";
};

// @public
function pickObjectKey<P extends {}>(obj: Object, keys: (keyof P)[] | Set<keyof P>, target?: Object): P;

// @public (undocumented)
function pickObjectKey(obj: Object, keys: string[] | Set<any>, target?: Object): Record<string, unknown>;

// @public (undocumented)
interface PromiseHandle<T> {
    // (undocumented)
    reject(reason?: any): void;
    // (undocumented)
    resolve(data: T): void;
}

// @public (undocumented)
interface Queue<T> {
    head?: T;
    push(data: T): void;
    shift(): T;
}

// @public
function randomInt(max: number): number;

// @public
function randomInt(min: number, max: number): number;

// @public
function randomString(len: number, minUnicode?: number, maxUnicode?: number): string;

// @public
function removeUndefinedKey<T extends Obj>(obj: T, deep?: boolean): T;

// @public (undocumented)
function retainDecimalsFloor(num: number, raids?: number): number;

// @public (undocumented)
function retainDecimalsRound(num: number, raids?: number): number;

// @public
const runtimeEngine: "node" | "browser" | "deno" | "bun" | "unknown";

// @public
function setInterval_2(fn: VoidFn, intervalTime?: number): () => void;

// @public
function setTimer(fn: VoidFn, timeout?: number): () => void;

// @public (undocumented)
type SinglyLinkList<T extends object = {}> = T & {
    next?: SinglyLinkList<T>;
};

// @alpha (undocumented)
class StepsByteParser<T> extends ByteParser<T> {
    constructor(opts: {
        first: BySteps<any>;
        final?: (data: any) => T;
    }, ...steps: ((data: any) => BySteps<any>)[]);
    // (undocumented)
    next(chunk: Uint8Array): boolean;
    // (undocumented)
    step: number;
}

// @public
interface TerminablePromise<T> extends Promise<T> {
    // (undocumented)
    abort(reason?: Error): void;
}

// @public
class TimeoutError extends Error {
    constructor(time?: number);
}

// @public
function toErrorStr(err?: any): string;

// @public (undocumented)
const TYPE_CHECK_FN: unique symbol;

// @public (undocumented)
interface TypeChecker<T = unknown> {
    // (undocumented)
    [TYPE_CHECK_FN]: TypeCheckFn<T>;
    baseType?: BasicType;
    // (undocumented)
    optional?: boolean;
}

// @public
const typeChecker: {
    numberRange(min: number, max?: number): TypeCheckFn<number>;
    instanceof<T extends new (...args: any[]) => any>(obj: T): TypeCheckFn<InstanceType<T>>;
    union<T extends ExceptType[]>(types: ExceptType[]): TypeCheckFn<InferExcept<T>> | TypeChecker<InferExcept<T>>;
    optional: typeof optional;
    array: typeof array;
    record: typeof record;
    arrayType<T extends ExceptType>(type: T, length?: number): TypeCheckFn<InferExcept<T>[]>;
};

// @public (undocumented)
interface TypeCheckFn<T = any> {
    // (undocumented)
    (val: any, option: Readonly<TypeCheckOptions>): TypeCheckFnCheckResult<T>;
    baseType?: BasicType;
}

// Warning: (ae-forgotten-export) The symbol "TypeCheckError" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TypeCheckReplace" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type TypeCheckFnCheckResult<T = unknown> = TypeCheckError | TypeCheckReplace<T> | void;

// @public (undocumented)
interface TypeCheckOptions {
    checkAll?: boolean;
    policy?: "pass" | "delete" | "error";
}

// @public (undocumented)
class TypeError_2 extends Error {
    constructor(cause: TypeErrorDesc_2, msg?: string);
    // Warning: (ae-forgotten-export) The symbol "TypeErrorDesc_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    cause: TypeErrorDesc_2;
}

// @public
type TypeErrorDesc = string | {
    [key: string]: TypeErrorDesc;
};

// @public
class UniqueKeyMap<T = any> extends Map<number, T> {
    constructor(maxSize: number);
    allocKeySet(data: T, safe?: undefined | false): number;
    allocKeySet(data: T, safe?: boolean): number | null;
    // @deprecated
    allowKeySet(data: T, safe?: undefined | false): number;
    // @deprecated (undocumented)
    allowKeySet(data: T, safe?: boolean): number | null;
    // (undocumented)
    clear(): void;
    // (undocumented)
    delete(key: number): boolean;
    // (undocumented)
    get freeRange(): number;
    // (undocumented)
    get freeSize(): number;
    // (undocumented)
    get lastPointer(): number;
    // (undocumented)
    readonly maxSize: number;
    set(key: number, data: T): this;
    // (undocumented)
    get startPointer(): number;
    take(key: number): T | undefined;
    update(key: number, data: T): boolean;
}

// @public
interface VoidFn {
    // (undocumented)
    (): void;
}

// @public (undocumented)
interface WithPromise<T, R = any> {
    // (undocumented)
    promise: Promise<T>;
    // (undocumented)
    reject(data: R): void;
    // (undocumented)
    resolve(data: T): void;
}

// @public
function withPromise<T, R = any, E extends object = {}>(handle?: E): WithPromise<T, R> & E;

// Warnings were encountered during analysis:
//
// src/core/type_check/type_checker.ts:168:63 - (ae-forgotten-export) The symbol "optional" needs to be exported by the entry point index.d.ts
// src/core/type_check/type_checker.ts:168:63 - (ae-forgotten-export) The symbol "array" needs to be exported by the entry point index.d.ts
// src/core/type_check/type_checker.ts:168:63 - (ae-forgotten-export) The symbol "record" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
